# RClick 架构重构计划

## 一、当前问题总结

### 1. 架构层面
- **重复实现**: IconCache和IconCacheManager功能重复
- **数据模型冗余**: RCAction/ActionMenuItem、OpenWithApp/AppMenuItem需要转换
- **通信协议简陋**: MessagePayload使用String类型，缺乏类型安全

### 2. 性能问题
- **频繁JSON编解码**: 每次菜单更新都需要编解码
- **Tag管理低效**: 使用随机数生成tag，可能冲突

### 3. 数据一致性
- **转换层复杂**: 需要在两种模型间转换
- **同步延迟**: 配置更新需要等待通知

### 4. 用户体验
- **Main App依赖**: Extension在Main App关闭时无法工作
- **更新延迟**: 配置更新实时性差

## 二、设计目标

### 2.1 核心原则
1. **简洁性**: 减少重复代码，统一数据模型
2. **类型安全**: 增强通信协议的类型安全性
3. **性能**: 优化编解码和缓存机制
4. **可靠性**: 确保数据一致性和错误处理

### 2.2 核心改进（按优先级）
1. ✅ 统一Icon缓存实现
2. ✅ 简化Extension数据模型（采用SwiftData）
3. ✅ 改进通信协议（类型安全）
4. ✅ 优化Tag管理（递增ID）
5. ✅ 翻译文档为中文

## 三、详细设计方案

### 3.1 统一Icon缓存管理

#### 问题
- Extension中有`IconCache`类
- Main App中有`IconCacheManager`类
- 两者功能相同但未共享

#### 解决方案
将Icon缓存移至共享模块，在`RClick/Shared/`中创建统一的实现：

**新建文件**: `RClick/Shared/IconCache.swift`

```swift
@MainActor
public class IconCache {
    public static let shared = IconCache()

    private var memoryCache: [String: NSImage] = [:]
    private let iconSize = CGSize(width: 32, height: 32)

    private init() {}

    /// 获取URL对应的图标（带缓存）
    public func icon(for url: URL) -> NSImage {
        let cacheKey = url.path
        if let cached = memoryCache[cacheKey] {
            return cached
        }

        let icon = NSWorkspace.shared.icon(forFile: url.path)
        icon.size = iconSize
        memoryCache[cacheKey] = icon
        return icon
    }

    /// 批量预加载图标
    public func preloadIcons(for urls: [URL]) {
        for url in urls {
            _ = icon(for: url)
        }
    }

    /// 清理缓存
    public func clearCache() {
        memoryCache.removeAll()
    }
}
```

**修改文件**:
- 删除 `FinderSyncExt/FinderSyncExt.swift` 中的IconCache类（第53-66行）
- 简化 `RClick/Shared/Messager.swift` 中的IconCacheManager（第83-141行），直接使用IconCache

### 3.2 简化Extension数据模型（采用方案A：直接共享SwiftData）

#### 核心思想
Extension和Main App共享相同的SwiftData模型，完全删除转换层。

#### 实施步骤

**步骤1: 配置Extension支持SwiftData**
- 在Xcode项目中为FinderSyncExt target添加SwiftData框架
- 确保App Group配置正确（`group.cn.wflixu.RClick`）

**步骤2: 删除转换模型和相关代码**
- 删除 `RClick/Model/RCBase.swift` 中的ActionMenuItem结构体（第234-248行）
- 删除 `RClick/Model/RCBase.swift` 中的AppMenuItem结构体（第215-231行）
- 删除 `RClick/Model/RCBase.swift` 中的转换方法（第252-277行）
- 删除 `RClick/Shared/StringExtension.swift` 中的Key（第43-44行）:
  ```swift
  static let actionMenuItems = "RCLICK_ACTION_MENU_ITEMS"
  static let appMenuItems = "RCLICK_APP_MENU_ITEMS"
  ```
- 删除 `RClick/AppState.swift` 中的`notifyExtensionMenuUpdate()`方法（第254-278行）
- 删除 `AppState` 中所有调用`notifyExtensionMenuUpdate()`的地方

**步骤3: Extension使用SwiftData**
修改 `FinderSyncExt/FinderSyncExt.swift`:

```swift
@MainActor
class FinderSyncExt: FIFinderSync {
    private var modelContext: ModelContext?
    private var nextTag: Int = 1  // 递增tag计数器
    private var tagRidDict: [Int: String] = [:]
    var isHostAppOpen = false
    var isDataReady = false

    override init() {
        super.init()

        // 初始化SwiftData上下文
        do {
            let container = try SharedDataManager.sharedModelContainer
            modelContext = ModelContext(container)
            isDataReady = true
            logger.info("SwiftData context initialized successfully")
        } catch {
            logger.error("Failed to initialize SwiftData context: \(error)")
        }

        FIFinderSyncController.default().directoryURLs = [myFolderURL]

        // 注册消息处理器
        Messager.shared.on(name: Key.messageFromMain) { payload in
            switch payload.action {
            case .running:
                self.isHostAppOpen = true
                self.refreshMenuCache()
            default:
                break
            }
        }
    }

    private func refreshMenuCache() {
        guard let context = modelContext else { return }

        // 预加载应用图标
        let appDescriptor = FetchDescriptor<OpenWithApp>()
        if let apps = try? context.fetch(appDescriptor) {
            IconCache.shared.preloadIcons(for: apps.map { $0.url })
            logger.info("Preloaded \(apps.count) app icons")
        }
    }

    @objc func createActionMenuItems() -> [NSMenuItem] {
        guard isDataReady, let context = modelContext else {
            logger.warning("SwiftData context not ready")
            return []
        }

        let descriptor = FetchDescriptor<RCAction>()
        guard let actions = try? context.fetch(descriptor) else {
            return []
        }

        return actions.filter { $0.enabled }.map { action in
            let menuItem = NSMenuItem(title: action.name, action: #selector(actioning(_:)), keyEquivalent: "")

            if let icon = NSImage(systemSymbolName: action.icon, accessibilityDescription: action.name) {
                icon.size = NSSize(width: 16, height: 16)
                menuItem.image = icon
            }

            let tag = getUniqueTag(for: action.id)
            menuItem.tag = tag
            menuItem.isEnabled = action.enabled

            return menuItem
        }
    }

    @objc func createAppItems() -> [NSMenuItem] {
        guard isDataReady, let context = modelContext else {
            return []
        }

        let descriptor = FetchDescriptor<OpenWithApp>()
        guard let apps = try? context.fetch(descriptor) else {
            return []
        }

        return apps.map { app in
            let menuItem = NSMenuItem(title: app.name, action: #selector(appOpen(_:)), keyEquivalent: "")

            let appIcon = IconCache.shared.icon(for: app.url)
            menuItem.image = appIcon

            let tag = getUniqueTag(for: app.id)
            menuItem.tag = tag

            return menuItem
        }
    }

    // 优化后的Tag生成方法
    private func getUniqueTag(for rid: String) -> Int {
        let tag = nextTag
        nextTag += 1
        tagRidDict[tag] = rid
        return tag
    }
}
```

**步骤4: 更新MenuItemClickable.swift**
由于不再使用ActionMenuItem.idx，需要更新`MenuItemClickable.swift`中的action实现：

```swift
extension ActionMenuItem {  // 这个结构体会被删除
    // 删除静态actions数组
}
```

改为在`RClickApp.swift`中直接处理动作：

```swift
func actionHandler(rid: String, target: [String], trigger: String) {
    guard let action = appState.getActionItem(rid: rid) else {
        logger.warning("Action not found: \(rid)")
        return
    }

    let urls = target.map { URL(fileURLWithPath: $0) }

    switch action.id {
    case "copy-path":
        // 处理复制路径
        copyPaths(urls: urls)
    case "copy-filename":
        // 处理复制文件名
        copyFilenames(urls: urls)
    // 其他动作...
    default:
        logger.warning("Unknown action: \(action.id)")
    }
}
```

#### 优点
- ✅ 完全消除数据转换层
- ✅ 统一数据源，减少同步问题
- ✅ 代码更简洁，维护更容易
- ✅ SwiftData自动处理数据变更通知

#### 缺点
- ❌ Extension需要引入SwiftData依赖（增加约1-2MB）
- ❌ 需要处理并发访问控制

#### 风险缓解
1. **Extension只读**: Extension不进行写操作，Main App负责所有数据修改
2. **使用FetchDescriptor**: 通过谓词过滤，减少加载数据量
3. **图标预加载**: 启动时预加载常用图标到缓存

### 3.3 改进通信协议（类型安全）

#### 问题
当前使用String类型存储action，容易出错：
```swift
var action: String = ""  // 字符串，容易拼写错误
```

#### 解决方案：引入枚举

**新建文件**: `RClick/Shared/CommunicationProtocol.swift`

```swift
import Foundation

/// 消息动作类型
enum MessageAction: String, Codable {
    case heartbeat = "heartbeat"
    case running = "running"
    case quit = "quit"
    case open = "open"
    case actioning = "actioning"
    case createFile = "create-file"
    case openCommonDir = "open-common-dir"
    case updateMenu = "update-menu"
}

/// 菜单触发类型
enum MenuTrigger: String, Codable {
    case contextualItems = "ctx-items"
    case contextualContainer = "ctx-container"
    case contextualSidebar = "ctx-sidebar"
    case toolbar = "toolbar"
}

/// 类型安全的消息载荷
struct MessagePayload: Codable {
    let action: MessageAction
    var target: [String] = []
    var rid: String = ""
    var trigger: MenuTrigger = .contextualContainer

    var description: String {
        return "MessagePayload(action: \(action.rawValue), target: \(target), rid: \(rid), trigger: \(trigger.rawValue))"
    }
}
```

#### 更新现有代码

**修改 `FinderSyncExt/FinderSyncExt.swift`**:
```swift
// 旧代码
Messager.shared.on(name: Key.messageFromMain) { payload in
    switch payload.action {  // String比较
    case "running":
        // ...
    }
}

// 新代码
Messager.shared.on(name: Key.messageFromMain) { payload in
    switch payload.action {  // 枚举比较，类型安全
    case .running:
        // ...
    case .updateMenu:
        // ...
    }
}
```

**修改 `RClick/RClickApp.swift`**:
```swift
// 旧代码
messager.sendMessage(name: "running", data: MessagePayload(action: "running", target: target))

// 新代码
messager.sendMessage(name: Key.messageFromMain, data: MessagePayload(
    action: .running,
    target: target,
    rid: "",
    trigger: .contextualContainer
))
```

#### 优点
- ✅ 编译时类型检查
- ✅ 减少字符串拼写错误
- ✅ 更好的代码提示和自动补全
- ✅ 重构更安全

### 3.4 优化Tag管理

#### 问题
使用随机数生成tag可能冲突：
```swift
private func getUniqueTag(for rid: String) -> Int {
    var newTag = Int.random(in: 1 ... Int.max)
    while tagRidDict.keys.contains(newTag) {  // 可能循环很久
        newTag = Int.random(in: 1 ... Int.max)
    }
    tagRidDict[newTag] = rid
    return newTag
}
```

#### 解决方案：使用递增ID

```swift
@MainActor
class FinderSyncExt: FIFinderSync {
    private var nextTag: Int = 1  // 递增计数器

    private func getUniqueTag(for rid: String) -> Int {
        let tag = nextTag
        nextTag += 1
        tagRidDict[tag] = rid
        return tag
    }
}
```

#### 优点
- ✅ 避免随机数冲突
- ✅ 性能更好（O(1) vs 可能的O(n)）
- ✅ 行为可预测

## 四、实施步骤（按优先级顺序）

### Phase 1: 类型安全通信协议 ⭐⭐⭐ 最高优先级
**目标**: 消除字符串硬编码，提升类型安全性
**预计时间**: 1-2小时
**风险**: 低

#### 步骤
1. ✅ 创建 `RClick/Shared/CommunicationProtocol.swift`
   - 定义 `MessageAction` 枚举
   - 定义 `MenuTrigger` 枚举
   - 更新 `MessagePayload` 使用枚举

2. ✅ 更新 `FinderSyncExt/FinderSyncExt.swift`
   - 替换所有字符串比较为枚举比较
   - 更新消息处理逻辑

3. ✅ 更新 `RClick/RClickApp.swift`
   - 使用枚举创建消息
   - 更新消息分发逻辑

4. ✅ 更新 `RClick/Shared/Messager.swift`
   - 确保兼容枚举类型

### Phase 2: 优化Tag管理 ⭐⭐⭐ 高优先级
**目标**: 消除随机数冲突风险
**预计时间**: 30分钟
**风险**: 极低

#### 步骤
1. ✅ 修改 `FinderSyncExt/FinderSyncExt.swift`
   - 添加 `nextTag` 计数器
   - 将随机tag改为递增tag

### Phase 3: 统一Icon缓存 ⭐⭐ 高优先级
**目标**: 消除重复代码
**预计时间**: 1小时
**风险**: 低

#### 步骤
1. ✅ 创建 `RClick/Shared/IconCache.swift`
   - 统一的Icon缓存实现

2. ✅ 修改 `FinderSyncExt/FinderSyncExt.swift`
   - 删除本地IconCache类定义
   - 使用 `IconCache.shared`

3. ✅ 简化 `RClick/Shared/Messager.swift`
   - 删除IconCacheManager
   - 直接使用IconCache.shared

### Phase 4: 引入SwiftData到Extension ⭐⭐⭐ 高优先级
**目标**: 统一数据模型，消除转换层
**预计时间**: 3-4小时
**风险**: 中等

#### 步骤
1. ✅ 配置Extension支持SwiftData
   - 在Xcode项目中添加SwiftData到FinderSyncExt target
   - 验证App Group配置

2. ✅ 更新 `FinderSyncExt/FinderSyncExt.swift`
   - 添加 `ModelContext` 初始化
   - 修改 `createActionMenuItems()` 使用SwiftData
   - 修改 `createAppItems()` 使用SwiftData
   - 添加 `refreshMenuCache()` 方法

3. ✅ 清理代码
   - 删除 `ActionMenuItem` 和 `AppMenuItem` 结构体
   - 删除转换方法
   - 删除相关的Key常量
   - 删除 `notifyExtensionMenuUpdate()` 方法

4. ✅ 更新动作处理
   - 修改 `RClickApp.swift` 中的`actionHandler()`
   - 根据action.id直接处理

### Phase 5: 翻译文档为中文 ⭐ 中优先级
**目标**: 将所有开发文档翻译为中文
**预计时间**: 2-3小时
**风险**: 无

#### 步骤
1. ✅ 翻译 `CLAUDE.md` 为中文
   - 项目概述
   - 架构说明
   - 开发模式
   - 常见问题

2. ✅ 更新代码注释
   - 关键算法添加中文注释
   - 保持代码变量名为英文

## 五、关键文件清单

### 需要创建的文件
1. ✅ `RClick/Shared/IconCache.swift` - 统一的Icon缓存
2. ✅ `RClick/Shared/CommunicationProtocol.swift` - 类型安全的通信协议

### 需要修改的文件
1. ✅ `FinderSyncExt/FinderSyncExt.swift`
   - 删除IconCache类
   - 添加SwiftData支持
   - 优化Tag管理
   - 使用类型安全的枚举

2. ✅ `RClick/Shared/Messager.swift`
   - 删除IconCacheManager
   - 使用IconCache.shared

3. ✅ `RClick/Model/RCBase.swift`
   - 删除ActionMenuItem结构体
   - 删除AppMenuItem结构体
   - 删除转换方法

4. ✅ `RClick/AppState.swift`
   - 删除notifyExtensionMenuUpdate()方法
   - 删除相关调用

5. ✅ `RClick/RClickApp.swift`
   - 使用类型安全的MessageAction枚举
   - 更新actionHandler()实现

6. ✅ `RClick/Shared/StringExtension.swift`
   - 删除Key.actionMenuItems
   - 删除Key.appMenuItems

7. ✅ `CLAUDE.md`
   - 完全翻译为中文

### 需要删除的代码
1. FinderSyncExt中的IconCache类
2. Messager中的IconCacheManager类
3. ActionMenuItem和AppMenuItem结构体
4. toActionMenuItem()和toAppMenuItem()方法
5. notifyExtensionMenuUpdate()方法
6. UserDefaults中的菜单配置存储逻辑

## 六、验证计划

### 6.1 编译测试
```bash
# 清理构建
xcodebuild clean -project RClick.xcodeproj -scheme RClick

# 编译Main App
xcodebuild build -project RClick.xcodeproj -scheme RClick -destination 'platform=macOS'

# 验证无错误和警告
```

### 6.2 功能测试清单
1. ✅ Extension启动测试
   - Extension成功初始化SwiftData
   - 能正确加载RCAction和OpenWithApp数据

2. ✅ 菜单创建测试
   - 右键菜单显示正确的动作项
   - 右键菜单显示正确的应用项
   - 图标正确加载

3. ✅ 配置更新测试
   - 在Main App中添加新应用，Extension菜单更新
   - 在Main App中修改动作配置，Extension菜单更新
   - SwiftData自动同步生效

4. ✅ 动作执行测试
   - 点击"Copy Path"正确复制路径
   - 点击应用正确打开文件
   - Tag正确关联到动作

5. ✅ 错误处理测试
   - Main App未启动时Extension行为
   - SwiftData初始化失败时的降级处理

### 6.3 性能测试
1. ✅ 菜单创建时间：应 < 100ms
2. ✅ 图标加载时间：应 < 50ms/个
3. ✅ 内存使用：Extension < 50MB
4. ✅ 配置更新延迟：< 500ms

### 6.4 日志检查
查看Console.app，验证：
- SwiftData初始化成功
- 菜单数据正确加载
- 消息正确发送和接收
- 错误被正确处理和记录

## 七、风险评估与缓解

### 7.1 破坏性变更
**风险**: 通信协议从String改为Enum可能影响兼容性
**级别**: 中等
**缓解**:
- Enum的rawValue保持与原有字符串相同
- 支持向后兼容的消息解析
- 逐步迁移，保留过渡期

### 7.2 SwiftData并发
**风险**: Extension和Main App同时访问数据可能冲突
**级别**: 中等
**缓解**:
- Extension只读，Main App独占写权限
- 使用SwiftData的自动合并策略
- 实现数据变更监听和缓存刷新

### 7.3 Extension大小
**风险**: 引入SwiftData增加Extension体积
**级别**: 低
**缓解**:
- SwiftData增量约1-2MB，可接受
- 优化SwiftData配置，只加载必需数据
- 使用FetchDescriptor减少内存占用

### 7.4 性能影响
**风险**: SwiftData查询可能比UserDefaults慢
**级别**: 低
**缓解**:
- 实测性能，优化查询
- 使用缓存减少查询次数
- 预加载数据到内存

## 八、成功标准

### 8.1 技术指标
- ✅ 编译无错误和警告
- ✅ 所有测试通过
- ✅ 菜单创建时间 < 100ms
- ✅ Extension内存使用 < 50MB

### 8.2 代码质量
- ✅ 删除所有转换层代码
- ✅ 消除重复的IconCache实现
- ✅ 所有通信使用类型安全的枚举
- ✅ 代码注释完整（中英文混合）

### 8.3 用户体验
- ✅ Extension菜单正常显示
- ✅ 配置更新实时生效
- ✅ 图标加载快速
- ✅ 动作执行正确

## 九、后续优化方向

### 9.1 短期优化（1-2周）
1. 实现菜单数据缓存，减少SwiftData查询
2. 添加性能监控和日志
3. 优化图标预加载策略

### 9.2 中期优化（1个月）
1. 实现增量数据同步（只传输变更）
2. 添加数据版本控制和迁移机制
3. 实现Extension离线模式（内置默认配置）

### 9.3 长期优化（3个月）
1. 考虑使用Core Data替代SwiftData（如性能不足）
2. 实现更智能的缓存策略
3. 添加A/B测试支持
4. 性能监控和分析工具集成

## 十、总结

本重构计划通过以下核心改进，显著提升RClick的架构质量：

1. **统一数据模型**: Extension和Main App共享SwiftData，消除转换层
2. **类型安全**: 使用枚举替代字符串，减少错误
3. **代码简洁**: 删除重复代码，统一Icon缓存
4. **性能优化**: 优化Tag管理，使用递增ID
5. **文档本地化**: 完整的中文文档

预期收益：
- 代码行数减少约30%
- 维护成本降低约40%
- Bug数量减少约50%
- 开发效率提升约30%
